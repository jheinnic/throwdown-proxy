import {MonoTypeOperatorFunction, OperatorFunction} from 'rxjs';
import {MerkleLayerLocator} from '../locator/merkle-layer-locator.interface';
import {MerkleSeriesLocator} from '../locator/merkle-series-locator.interface';
import {MerkleDigestLocator} from '../locator/merkle-digest-locator.interface';
import {MerkleProofLocator} from '../locator/merkle-proof-locator';

export interface IMerkleCalculatorOperators {

   /**
    * Given a storage layer index, return the merkle tree layer that maps to it as root.
   mapStorageLevelToRootDepth(): OperatorFunction<number, MerkleLayerLocator>;
    */

   /**
    * Given a storage layer index, return the merkle tree layer at the base of its
    * slice of Merkle subtrees.
   mapStorageLevelToLeafDepth(): OperatorFunction<number, MerkleLayerLocator>;
    */

   /**
    * Given a Merkle Tree layer index, return the storage layer it can be found in.
    *
    * TODO: This needs a better signature!!!
    */
   mapDepthToStorageLevel(): MonoTypeOperatorFunction<MerkleLayerLocator>;

   recordAddressToLocator(): OperatorFunction<number, MerkleDigestLocator>;

   digestPositionToLocator(): OperatorFunction<number, MerkleDigestLocator>;

   depthAndIndexToLocator(): OperatorFunction<[number, number], MerkleDigestLocator>;

   getSiblingLocator( ): MonoTypeOperatorFunction<MerkleDigestLocator>;

   getMerkleProofLocator(): OperatorFunction<MerkleDigestLocator, MerkleProofLocator>;

   getMerkleDigestRunLocators(runLength: number): OperatorFunction<MerkleLayerLocator, MerkleSeriesLocator>;

   // getBlockMappedMerkleLayerLocators(): Observable<MerkleLayerLocator>;
}